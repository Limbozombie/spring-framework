<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	   xsi:schemaLocation="
http://www.springframework.org/schema/beans 
http://www.springframework.org/schema/beans/spring-beans.xsd">


	<bean id="first" class="java.lang.String">
		<constructor-arg value="首先"/>
	</bean>


	<bean id="threadScopeBean" class="Chapter02.bean.Student" scope="thread">
		<property name="name" value="名字"/>
		<property name="age" value="20"/>
	</bean>

	<!--scope 默认为 singleton-->
	<bean id="singleton" class="Chapter02.bean.Student">
		<constructor-arg value="小明"/>
		<constructor-arg type="java.lang.Byte" value="23"/>
	</bean>


	<bean id="small2" class="Chapter02.bean.Student">
		<constructor-arg ref="first"/>
		<constructor-arg type="java.lang.Byte" value="23"/>
	</bean>


	<!--Student	必须提供无参构造器-->
	<bean id="small3" class="Chapter02.bean.Student">
		<property name="name" ref="first"/>
		<property name="age" value="23"/>
	</bean>


	<!-- depends-on
		要求容器在初始化 small4 之前首先实例化 first
		大部分情况下，是那些拥有静态代码块初始化代码或者数据库驱动注册之类的场景
		如有多个，逗号分割 -->
	<bean id="small4" class="Chapter02.bean.Student" depends-on="first">
		<property name="name" ref="first"/>
		<property name="age" value="23"/>
	</bean>

	<!--静态工厂-->
	<bean id="fooByClass" class="Chapter02.bean.Foo">
		<property name="barInstance" ref="barByClass"/>
	</bean>
	<bean id="barByClass" class="Chapter02.factory.BarInterfaceFactory" factory-method="getInstanceByClass"/>

	<!--静态工厂  有参数-->
	<bean id="fooWithPara" class="Chapter02.bean.Foo">
		<property name="barInstance" ref="barWithPara"/>
	</bean>
	<bean id="barWithPara" class="Chapter02.factory.BarInterfaceFactory" factory-method="getInstanceWithPara">
		<constructor-arg type="java.lang.String" value="name"/>
	</bean>

	<!--实例工厂-->
	<bean id="fooByInstance" class="Chapter02.bean.Foo">
		<property name="barInstance" ref="barByInstance"/>
	</bean>
	<bean id="barFactory" class="Chapter02.factory.BarInterfaceFactory"/>
	<bean id="barByInstance" factory-bean="barFactory" factory-method="getInstanceByInstance"/>


	<!--	FactoryBean -->
	<bean id="nextDayDateProvider" class="Chapter02.bean.NextDayDateProvider">
		<property name="dateOfNextDay" ref="nextDayDate"/>
	</bean>
	<bean id="nextDayDate" class="Chapter02.bean.NextDayDateFactoryBean"/>


	<!--	scope的使用“陷阱
	 studentPersister不是单例，但是student是单例，会导致所有studentPersister实例的student都是同一个
	 -->
	<bean id="singletonStudent" class="Chapter02.bean.Student" scope="singleton"/>
	<bean id="studentPersister" class="Chapter02.bean.StudentPersister" scope="prototype">
		<property name="student" ref="singletonStudent"/>
	</bean>

	<!--	方法注入
	<public|protected> [abstract] <return-type> theMethodName(no-arguments);
	方法必须能够被子类实现或者覆写，因为容器会为我们要进行方法注入的对象使用Cglib动态生成一个子类实现，从而替代当前对象
	-->
	<bean id="prototypeStudent" class="Chapter02.bean.Student" scope="prototype"/>
	<bean id="lookUpStudentPersister" class="Chapter02.bean.StudentPersister" scope="prototype">
		<lookup-method name="getStudent" bean="prototypeStudent"/>
	</bean>

	<!--	方法替换
	与方法注入只是通过相应方法为主体对象注入依赖对象不同，方法替换更多体现在方法的实现层
	面上，它可以灵活替换或者说以新的方法实现覆盖掉原来某个方法的实现逻辑。基本上可以认为，方
	法替换可以帮助我们实现简单的方法拦截功能-->
	<bean id="beReplaced" class="Chapter02.bean.StudentPersister">
		<replaced-method name="getTime" replacer="methodReplacerImpl"/>
	</bean>
	<bean id="methodReplacerImpl" class="Chapter02.bean.MethodReplacerImpl"/>


	<!-- 实现BeanFactoryAware接口	-->
	<bean id="awareStudent" class="Chapter02.bean.Student" scope="prototype"/>
	<bean id="awareStudentPersister" class="Chapter02.bean.StudentPersister"/>


	<!--	使用ObjectFactoryCreatingFactoryBean
		Spring 提供的一个FactoryBean实现，它返回一个ObjectFactory实例
		从这个ObjectFactory实例可以为我们返回容器管理的相关对象。
		实际上，ObjectFactoryCreatingFactoryBean 实现了BeanFactoryAware接口
		它返回的ObjectFactory实例只是特定于与Spring容器进行交互的一个实现而已。
		使用它的好处就是，隔离了客户端对象对BeanFactory的直接引用。-->
	<bean id="objectFactoryStudent" class="Chapter02.bean.Student" scope="prototype"/>
	<bean id="objectFactoryStudentPersister" class="Chapter02.bean.StudentPersister">
		<property name="objectFactory" ref="objectBeanFactory"/>
	</bean>
	<bean id="objectBeanFactory" class="org.springframework.beans.factory.config.ObjectFactoryCreatingFactoryBean">
		<property name="targetBeanName" value="objectFactoryStudent"/>
	</bean>

	<bean id="dataSource" class="Chapter02.bean.DataSource">
		<property name="url" value="${jdbc.url}"/>
		<property name="driverClassName" value="${jdbc.driver}"/>
		<property name="username" value="${jdbc.username}"/>
		<property name="password" value="${jdbc.password}"/>
	</bean>
	<bean id="placeholder" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
		<property name="locations">
			<list>
				<value>jdbc.properties</value>
			</list>
		</property>
	</bean>

	<bean id="override" class="org.springframework.beans.factory.config.PropertyOverrideConfigurer">
		<property name="location" value="overrideJdbc.properties"/>
	</bean>


	<bean id="localDateWrapper" class="Chapter02.bean.LocalDateWrapper">
		<property name="date" value="2020/04/01"/>
	</bean>
	<bean id="customEditorConfigurer" class="org.springframework.beans.factory.config.CustomEditorConfigurer">
		<property name="propertyEditorRegistrars">
			<list>
				<ref bean="datePropertyEditorRegistrar"/>
			</list>
		</property>
	</bean>
	<bean id="datePropertyEditorRegistrar" class="Chapter02.bean.DatePropertyEditorRegistrar">
		<property name="editor" ref="editor"/>
	</bean>
	<bean id="editor" class="Chapter02.bean.DatePropertyEditor">
		<property name="datePattern" value="yyyy/MM/dd"/>
	</bean>

	<bean id="translatePostProcessor" class="Chapter02.bean.TranslatePostProcessor"/>
	<bean id="translatableStudent" class="Chapter02.bean.Student">
		<property name="source" value="待翻译的句子"/>
	</bean>

	<bean id="initStudent" class="Chapter02.bean.Student"/>
</beans>